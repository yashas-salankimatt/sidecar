Go-Based Tmux UI Integration: Techniques, Challenges, and Best Practices

> **Note:** This project uses direct tmux CLI commands via `exec.Command`, not a wrapper library like go-tmux. The concepts from this guide apply, but implementation uses raw CLI invocations (e.g., `exec.Command("tmux", "capture-pane", "-p", "-t", paneID)`).

1. Forwarding Input to Tmux and Capturing Output

Building a Go "tmux viewer" involves treating tmux as the backend PTY and shuttling I/O between tmux and your UI. A proven approach is to use tmux's own commands to interface with panes. For example, tmux's control mode or CLI commands can send keystrokes and capture screen content. In one discussion, developers recommend using tmux capture-pane to poll a pane's text output, and tmux send-keys to inject input ￼. This essentially turns tmux into a headless terminal driver: you repeatedly capture the pane's screen state (including ANSI escapes for colors if needed) and render it in your UI, while sending user key events into tmux. The go-tmux library encapsulates such logic (e.g. Pane.Capture() to get text, Pane.RunCommand() or send-keys for input) ￼ ￼.

Always use `capture-pane` with the `-e` flag to preserve ANSI escape codes (colors, styles). Without `-e`, color and formatting information is stripped from the output.

Open-source tools like Teleconsole and tty-share follow this model. Teleconsole uses an SSH-based approach (via Teleport), but still ultimately allocates a PTY and shares it ￼ ￼. In a similar vein, tty-share spawns a local shell in a PTY and relays its output to clients. Its code shows a PTY master reading/writing loop (see pty_master.go in tty-share) and uses tmux indirectly only when multiple viewers attach. For a more tmux-specific solution, you can also attach to an existing tmux session in control mode (tmux -C). In control mode, tmux provides structured %output events with pane output and accepts commands for input. For example, attaching in control mode and issuing send-keys commands yields output events like %output %0 ... which you can parse ￼ ￼. This avoids writing a full VT100 parser yourself, since tmux sends already-rendered text (with cursor movements applied) as lines and encoded control sequences ￼ ￼. Many have leveraged this to create frontends; iTerm2’s tmux integration and others use control mode to get real-time pane updates. In summary, the core technique is to let tmux manage the terminal state – you pull the pane’s screen (via capture or control mode events) and push user input (via send-keys or writing to the tmux socket). This method is suggested as an alternative to writing a full terminal emulator ￼.

2. Cursor Position Tracking (and the “+1” Offset Mystery)

When rendering the tmux pane’s content in your custom UI, you also need to show the active cursor in the correct spot. Tmux keeps track of the cursor internally and exposes it via format variables. You can retrieve #{cursor_x} and #{cursor_y} for the pane’s current cursor coordinates ￼. Tmux reports these in zero-based coordinates (0,0 for top-left) ￼, which typically align with most UI frameworks’ indexing. However, several implementers have noticed an off-by-one issue in practice – a “mysterious +1 vertical offset” sometimes needed. This usually stems from confusion over indexing or including the cursor’s line in captured output. For example, one workaround is to add 1 to the cursor_y when using it to index into captured lines ￼. The need for this offset can depend on how you gather pane text. If you use tmux capture-pane -p, by default it does not include the trailing empty line where the cursor might be (tmux omits blank lines at bottom unless -J is used). In such cases, the cursor’s row index might appear one greater than the last captured line index. The solution is to capture with the -J flag (to include blank trailing lines) or adjust the index. As an example, a Kakoune integration script takes #{cursor_y} and uses it as the -E (end line) when capturing, often adding 1 to ensure the cursor’s line is included ￼.

Also note that tmux's cursor_flag (a boolean format variable) indicates if the cursor is currently shown or hidden (e.g. some full-screen apps hide the cursor) ￼ ￼. The viewer should honor this (don't draw a cursor if cursor_flag is 0). There are other cursor-related states tmux can report, like cursor_shape (block vs line vs underline) and cursor_blinking ￼ ￼, which might be overkill for basic use but are available. The main challenge has been ensuring the cursor is rendered at the correct line. The "+1" quirk is solved by aligning your capture method with tmux's coordinate system. In practice, many developers confirm that tmux's reported cursor_x/y are accurate for a 0-indexed grid ￼. If you see an off-by-one, double-check if you need to include the last line of the pane. Using capture-pane -e -p -J (to get all lines and escape codes) and then placing the cursor at (cursor_x, cursor_y) in that buffer is a reliable strategy. Tmux's own control mode, for instance, sends an %output line after a %end when content changes, so the final cursor position is implicitly at the end of the output stream unless moved explicitly ￼ ￼. In summary, trust tmux's coordinates but be mindful of how blank lines are handled.

> **Note on `-J` flag:** The `-J` flag behavior depends on the `tmux_interactive_input` feature flag. When this feature is enabled, `-J` is used to preserve trailing whitespace and blank lines for accurate cursor positioning. When disabled, `-J` may be omitted for simpler output handling.

(In some environments, terminal indexing differences led to confusion: e.g. older tmux versions or certain TERM settings might cause an off-by-one. But with modern tmux, cursor_y is the 0-based row. If necessary, consult tmux’s verbose log to see how it interprets cursor movement.)

3. Synchronizing Terminal Resizes between UI and Tmux

Keeping tmux's idea of the pane size in sync with your Bubble Tea (or other TUI) window is critical. If they diverge, you'll encounter wrapped or truncated lines and layout misalignment. For example, if tmux thinks the pane is 80 columns but your UI draws 100 columns, long lines will be hard-wrapped at 80 with trailing spaces, or if reversed, lines may get cut off. The best practice is to resize the tmux pane whenever your UI terminal resizes. Tmux offers a direct command for this: tmux resize-pane -x <cols> -y <rows> can set a pane to specific dimensions ￼. You can call this whenever you receive a Bubble Tea WindowSizeMsg. In control mode, there's also refresh-client -C <width>x<height> which informs tmux of a client's size. Open-source tmux integrations do use these: for instance, iTerm2 sends a resize control sequence to tmux on window changes. In one example, a user launching tmux via script explicitly resized the pane (tmux resize-pane -x 70 -y 20) as part of setup ￼, ensuring the content fit a 70x20 area. For detached sessions, resize-pane may not apply; use tmux resize-window -x <cols> -y <rows> (or new-session -x/-y) to force the window size.

Failure to sync sizes can cause subtle issues. One is horizontal padding or truncation – e.g., you might see an extra blank column at the pane edge or missing last character. This often means the widths differ by 1. Similarly, if the heights aren’t synced, tmux might think there are more lines in history than your UI shows. The remedy is straightforward: always propagate resize events. If using CLI commands, you might spawn tmux resize-pane via exec.Command in Go whenever you get a new terminal size. In control mode, you’d send the refresh-client -c <target-client> -x <cols> -y <rows> command (or use the %layout-change event to detect and handle it).

Additionally, consider tmux’s scroll region and history behavior. If your UI provides scrollback separate from tmux, you might want to disable tmux’s history (e.g., keep it small) to avoid large captures. However, if you rely on tmux’s scrollback, ensure you capture enough lines (-S - to get the entire scrollback if needed). Most implementations simply capture the visible pane (-S 0 -E -0 covers the on-screen content). Keeping dimensions in sync also avoids issues where tmux fills background with spaces if it thinks the pane is larger – no more weird padding artifacts. In summary, tie your UI and tmux pane dimensions together; this is essential for a clean, correct rendering ￼.

4. Bracketed Paste Mode Support

Bracketed paste mode is a feature where the terminal wraps pasted text with special escape sequences (ESC [200~ … ESC [201~) so that applications can treat paste differently from typed input. When tmux is used as the PTY backend, both tmux and the child application can be involved in bracketed paste. Tmux itself will honor bracketed paste requests from applications, and tmux can forward paste sequences from its clients. Notably, tmux exposes a flag #{bracketed_paste_flag} to indicate the mode is on ￼. In practice, if the application inside (like vim, nano, etc.) enables bracketed paste, tmux will expect to receive paste sequences from the terminal (your UI) and forward them. Your Go UI therefore should detect paste events (e.g. a user pressing a paste shortcut or middle-click if applicable) and send the bracketed paste sequence to tmux rather than raw text.

One approach is to wrap the pasted text manually: send \x1b[200~, then the text, then \x1b[201~ via tmux send-keys or by writing to tmux’s stdin. Ensure that these sequences are sent only once. A known pitfall is that if both your UI and tmux attempt to add paste wrappers, the application will see extra markers (for instance, some iTerm2 + tmux combinations led to “200~” appearing literally ￼). To avoid this, it’s best to let only the outermost terminal environment add the escapes. In this case, your custom UI is the “terminal” for tmux, so you should add ESC[200~...ESC[201~ around any multi-line or high-volume pasted content. Tmux will pass those escapes to the application, which will then know it’s a paste.

If you’re using control mode or a library, you might need to send the escape sequences as part of a command. For example, you can use tmux send-keys -l "<PasteContent>" for literal strings but that won’t automatically add bracket codes. Instead, you’d do something like: tmux send-keys "$(printf '\033[200~')" then send the text, then send \033[201~. Some terminal UI libraries allow you to capture clipboard events; Bubble Tea doesn’t provide paste events out of the box, so you’d need to integrate with the OS clipboard or have the user trigger it via an input box. But assuming you detect a paste, check if bracketed paste is enabled (tmux’s flag or possibly an environment variable). Tmux’s flag is true when any pane has requested it (e.g. shell enabled it). As a simplifying measure, you might always wrap paste text – at worst, if an app isn’t expecting it, it will see the markers and likely ignore them or print “200~”. Typically, though, modern shells enable bracketed paste by default, and tmux (since 2.6+) defaults to honoring it.

There was a known tmux issue where bright background colors in capture output weren’t preserved ￼ ￼, but that’s separate from paste. For paste: be mindful that tmux itself in copy mode uses paste buffers, but that’s unrelated to bracketed paste to applications. In summary, implement paste by wrapping the text with ESC[200~ and ESC[201~ if the app expects it. This ensures things like multiline paste into a shell won’t trigger unwanted autoindent or bracket artifacts. It’s the same approach actual terminals (xterm, iTerm2) use – your UI effectively acts as the terminal, so it must implement this behavior.

(In a complex scenario where tmux itself has its bracketed paste on (tmux command prompt supports it), you’d be nesting sequences. But generally, tmux passes through those sequences to the active pane. The key is to not double-wrap.)

5. Forwarding Mouse Events through Tmux

Forwarding mouse clicks, drags, and scrolls from a custom UI into a tmux session is challenging but feasible. Tmux, when mouse mode is on (tmux option set -g mouse on), will capture certain mouse events (for its copy-mode and pane resizing). If your goal is to let the application inside tmux receive the mouse events (e.g. a text editor or TUIs like htop that respond to clicks), you actually want tmux not to intercept them. One strategy is to keep mouse off in tmux, so that all mouse escape sequences are forwarded directly to the app. In that case, your UI’s responsibility is to encode mouse actions as terminal escape sequences and send them via tmux just like key presses.

Terminals encode mouse events in various modes (X10, UTF-8, SGR, etc.). Modern applications typically enable SGR extended mode (\x1b[?1000h and \x1b[?1006h). When that’s enabled, mouse clicks are reported as ESC [ < b;x;yM (for press) or m (for release), where b is button+modifier code, and x,y are coordinates. Your Bubble Tea program can capture mouse events via the tea.MouseMsg. For example, Bubble Tea supports basic mouse events if you enable it (ProgramOptions{MouseAll: true} in recent versions). Once you receive a mouse event with coordinates relative to your UI, you need to translate it to the pane coordinate system and output the corresponding escape. Tmux uses the standard xterm mouse encoding. If you send the proper escape to tmux (e.g. as part of a send-keys command or by writing to the tmux PTY), tmux will forward it to the application.

Crucially, you must offset the coordinates by +1 in the escape because mouse reporting uses 1-based positions. For example, a left-click (button 0) at column X=10, row Y=5 should be encoded as ESC [ < 0;10;5M (assuming 0 denotes left button press with no modifiers in SGR mode). In the classic decimal encoding (if an app for some reason used old mode), it would be ESC M <Char(x+32)><Char(y+32)> with a single byte for button+32. SGR is easier to construct as text. Many choose to always send SGR (1006) since tmux 2.1+ supports it and it handles large coordinates.

Edge cases: Scroll wheel events are encoded as “button” 64 and 65 (typically) for up/down. Drag events (movement with button held) have different codes (e.g. add 32). If your UI gets a drag, you should send the drag motion events as well (apps like vim will track selection). Also, tmux by default may not forward drag motions unless the application explicitly enabled “drag reporting” (1003h). Many full-screen apps only enable basic clicks (1002h: report button press/release and motion while pressed). So ensure you respect that – if a drag is outside the pressed region, it may not be sent unless in 1003 mode.

An example from tmux’s code: when in mouse mode, it translates terminal mouse escape sequences into its own internal events. If mouse off, it will just pass along the escapes to the pane. Thus, to forward properly, it’s often best to turn off tmux’s mouse mode (so tmux itself doesn’t try to act on the events). Then, when your app inside enables mouse tracking, your UI will get a MouseMsg and you construct an escape. There isn’t a readily available Go library doing this out-of-the-box, but the logic can be borrowed from terminal emulators. For instance, the Ghostty project (Zig-based terminal) or xterm.js documentation detail these encodings.

In summary, listen for UI mouse events, encode them as X10/SGR sequences, and send to tmux. As a concrete example: suppose the user clicks at pane-relative coordinates (cx, cy). If left-click, no mod: send \x1b[<0;{cx};{cy}M. If they release: send \x1b[<0;{cx};{cy}m (lowercase m for release in SGR). For scroll up: \x1b[<64;{cx};{cy}M (64 = scroll up code, often) and scroll down: 65. (Tmux will forward these to the app; if using alternate encoding, it would be different bytes.)

**Important:** Strip SGR mouse escape sequences from captured output. When applications have mouse mode enabled, these sequences may appear in the pane text. Removing them prevents visual artifacts in your rendered output.

One more wrinkle: if tmux’s mouse on is enabled, you might still forward events except tmux might intercept certain ones (like scroll to scroll its history). If you want the application to get the scroll wheel, consider leaving tmux’s mouse mode off and handling scroll entirely in-app, or if mouse mode on, set tmux set-option -g alternate-screen MouseWheelMode pane (available in newer tmux) to send wheel to pane. Generally, for a pure “viewer” approach, keep tmux’s own mouse interactions disabled and forward everything. This way, tools like ncmpcpp or vtop running inside tmux will think they are directly in a terminal with mouse support.

6. Handling Modified Keys (Shift/Ctrl + Arrows and Others)

Modified function keys and arrows are notoriously inconsistent across terminals. Many terminal emulators have their own escape sequences for keys like Shift+Arrow or Ctrl+Arrow, and some (like macOS Terminal.app) don’t even send distinct codes for certain combos ￼ ￼. In a Bubble Tea program, tea.KeyMsg will distinguish modifier + key if the underlying terminal sent a unique escape. For example, Shift+Up typically is reported by xterm as ESC [ 1;2A (where ;2 denotes the Shift modifier). Bubble Tea can parse that into a KeyMsg with .String()=="shift+up". However, not all terminals send that – the Terminal.app on macOS needed manual configuration to enable those sequences ￼. This explains why your Bubble Tea app might never see a shift+up event by default.

When integrating with tmux, there are a few layers of translation: your UI needs to get the key, then you need to forward it to tmux, which in turn delivers it to the application. Tmux by default recognizes xterm’s modifier key sequences. If you use send-keys with a key name like Up vs S-Up (tmux notation for Shift-Up), tmux will send the correct escape to the app ￼ ￼. But to use send-keys with modifiers, you must specify tmux’s notation (e.g. tmux send-keys -t pane Up for normal up, and tmux send-keys -t pane Shift-Up for shifted). Tmux’s send-keys accepts prefixes like C- and M- for Ctrl and Alt. Unfortunately Shift is only recognized in certain keys (arrow keys, function keys, etc.).

A practical tip: Check what escape code your terminal sends for a given combo and ensure tmux knows how to interpret it. For instance, in xterm or VT sequences:
• Shift+Arrow: ESC [ 1;2A (Up arrow example)
• Ctrl+Arrow: ESC [ 1;5A
• Shift+Tab: different story – often ESC [ Z which many programs consider a distinct key (like BackTab). Tmux has a known issue around <C-S-Tab> which was recently addressed (using BTab notation) ￼.

So in your viewer, if you capture a modified key, you need to decide how to forward it. If using control mode, you can send the literal escape sequence via send-keys -l (literal) option. For example, if Bubble Tea gives you a KeyMsg for “shift+up”, you could do: tmux send-keys -t X "[1;2A" (where is ESC). Alternatively, use the key name approach: tmux send-keys -t X PageUp for Shift+Up if tmux is configured to treat Shift+Up as PageUp (though that’s not default and not recommended). Better is to explicitly send the sequence. Tmux will just pass it through to the app (since it’s not a special tmux key unless you bound it).

Another hazard is Ctrl+Arrow on macOS – Terminal.app by default might use Ctrl+Arrow for Spaces or not send it. The Bubble Tea discussion you cited shows Terminal.app doesn’t send Shift+Up/Down without configuration ￼. So on some platforms you might simply never get those events in your Go program. The solution is to inform users (or in documentation) that to use those keys, they might need to adjust terminal settings. For instance, iTerm2 and Kitty do send distinct codes for shifted arrows by default, whereas macOS Terminal requires enabling “use option as meta” or similar for some combos.

For function keys with modifiers (F1–F12 + Shift/Ctrl/Alt), similar issues occur – they have well-defined xterm codes (e.g. F5 vs Shift+F5) which tmux can forward, but some terminals might not transmit them. Tmux also has an extended-keys option (since tmux 3.2) that can enable support for CSI u encoding (a newer way to encode modifiers beyond the traditional 1; modifiers range). If you find that certain keys aren’t being forwarded, ensure tmux show -g extended-keys is on if needed, and that your $TERM outside supports it.

In summary, the key mapping challenges boil down to availability and encoding. Use Bubble Tea’s key events to detect combos, and use tmux’s send-keys with the appropriate sequence or name. For example, one could maintain a mapping in Go: if msg.String() == “shift+up”, then output the known ESC sequence for Shift+Up. This way, you’re not relying on tmux’s key name parsing at all – you just deliver the actual ANSI code that a normal terminal would. The application inside will receive it as if a real terminal sent it. This approach is reliable as long as the app is using standard terminfo (which expects those sequences). Most curses-based apps do.

One must also consider Alt+key (Meta) – Bubble Tea will report e.g. “alt+x”. Terminals typically send ESC then the character for Meta modified keys. Tmux by default passes those through (unless you have escape-time messing up small delays). It’s usually fine to send an actual ESC followed by the character via send-keys for an Alt combination.

Finally, test a variety of keys in your environment. You might find, for example, that Shift+Space is indistinguishable from plain space (it is, in ASCII) – so some combos simply can’t be detected or forwarded. Or Ctrl+Space is ASCII NUL (0x00), which you can forward (tmux send-keys “C-Space” might not do what you think, you’d send a 0x00 byte). These edge cases are the same as any terminal: your UI program essentially needs to mimic a full keyboard->terminal translation. Referring to terminfo definitions for key codes (e.g. kUP5 might denote Shift+Up in terminfo) can be helpful to know the sequences.

To summarize: use tmux’s literal send or escape sequences to forward modified keys, and be aware of platform quirks. Many of these issues aren’t Go-specific but come from the terminal ecosystem. Testing on multiple terminals has shown that some keys won’t register without configuration ￼, so document those or find workarounds (perhaps allow user to press alternative keys or detect iTerm vs Terminal and warn accordingly).

7. High-Performance Output Polling with Adaptive Decay

Continuously reading and rendering a tmux pane can become CPU-intensive if done at a high frequency, especially when the pane is mostly idle. A common strategy is to use adaptive polling intervals (decay): poll very fast when output is bursting, and slow down when things are quiet. For instance, you might poll 60 times per second for a short period after detecting new output, then gradually back off to, say, 2 times per second after a second of no changes. This prevents wasting CPU on redundant redraws while still capturing bursts of text promptly.

One way to implement this in Go is with a loop that checks for changes in the captured pane content. If changes are found, reset your “high frequency” timer; if not, increase the wait interval up to some max (like 500ms or 1s). In a Bubble Tea architecture, you wouldn’t want to flood the Update with too many messages either – too many messages can back up the event loop and cause UI lag ￼. Indeed, as the Bubble Tea docs note, if your program generates messages faster than they can be processed, it will appear to stall ￼. A fast polling loop could do that by sending a new “PaneUpdated” message constantly. So decoupling the polling from the UI loop via Go routines and using channels with select-timeouts is wise.

A concrete model: Start at, say, 16ms interval (~60 FPS) whenever new output was seen in the last tick. Each time you poll and find no change, double the interval (32ms, 64ms, 128ms, … up to maybe 500ms). If you detect output on a slower interval, drop back to fast polling immediately (so you don’t miss subsequent rapid output). This exponential backoff is similar to techniques in networking and GUI rendering throttling. There may not be an off-the-shelf library for this, but it’s straightforward to code. The goal is to minimize CPU usage during idle periods (no need to redraw the same static screen dozens of times a second), without sacrificing responsiveness when the pane is active.

Another approach is event-driven: tmux’s control mode can notify on output, which could in theory let you avoid polling altogether. The %output notifications arrive when the pane produces data. However, even with control mode, if you want to maintain a local model of the screen, you often end up processing a lot of events (one per chunk of output). Some have used pause-after in control mode to buffer bursts and then fetch a chunk ￼ ￼, which is another way to reduce overhead (tmux can accumulate 100ms of output and send it in one go). If you stick to the simpler polling model via capture-pane, the adaptive delay strategy is a good compromise.

Ensure that your polling loop yields to other operations and doesn’t block the UI thread. Typically, run it in a separate goroutine and send results to the Bubble Tea model via messages. This way, the UI stays snappy. Also consider using time.Sleep or time.After for the delay, and context.Context to cancel the polling when the viewer exits.

High-performance tuning might also involve skipping redraws if nothing changed. If you capture the pane and it’s identical to the previous capture (and cursor position hasn’t changed), you can choose not to issue a Bubble Tea model.SetPaneContent(...) message, for example. This saves processing in the UI. The cost is that you must compare potentially large strings; a simpler heuristic is to hash the content or track a “last updated” timestamp from tmux (though tmux doesn’t give that directly per pane). Since capture-pane is relatively heavy (it has to serialize the pane data), reducing its calls when not needed is key.

Some open-source examples: not specific to tmux, but in the TUI world, game loops or monitoring dashboards do similar backoff. For instance, a dashboard that polls system stats might poll fast on active update and slow when stable. Your case is more complex because the “activity” is external (the shell or program output). One sign of activity is if the capture-pane output differs or if pane_cursor_y and pane_cursor_x are moving (cursor movement often accompanies output). You could optimize by checking tmux’s #{history_bytes} or similar as a quick indicator; if the history size increased, output happened ￼. (Tmux’s format history_bytes gives the number of bytes in pane history ￼, which will increase as new output arrives.) Polling just that (which is cheap) might tell you “something changed” and then you do a full capture. This is a clever trick to avoid capturing when idle.

In summary, implement a dynamic polling loop: rapid polling on recent output, and exponentially slower polling during inactivity. This yields low CPU usage in steady-state (when tmux is idle) while still catching bursts immediately. Keep in mind that extremely high output (e.g. yes command or a fast-scrolling log) might overwhelm your UI if you try to render every frame – in those cases, you might even skip frames (capture at, say, 30Hz max) to avoid overload. It's a balancing act: test with both slow and fast output scenarios to tune the decay parameters.

## Batch Capture Optimization

When polling multiple panes, coordinate goroutines to capture all active panes in one operation and cache results briefly (e.g., 300ms). This avoids redundant subprocess spawns and significantly reduces CPU overhead.

## Runaway Session Detection

Track polling frequency. If > 20 polls detect output within 3 seconds, the session is likely in a runaway state (e.g., `yes` command). Throttle to slower intervals (20s) to prevent CPU overload. Reset throttle when session becomes idle.

## Capture Size Limits

The maximum bytes captured from a tmux pane is configurable via `plugins.workspace.tmuxCaptureMaxBytes` in `~/.config/sidecar/config.json`. The default cap is 2MB to prevent memory issues with extremely large pane buffers.

8. Debugging and Instrumentation for Desynchronization Bugs

When you encounter subtle bugs like “missing output” or a “stale cursor” in your viewer, a methodical debugging approach is needed. One powerful technique is to log everything – both the data coming from tmux and the state changes in your UI. For example, in Bubble Tea you can instrument the Update to dump every message (keystrokes, ticks, etc.) to a file ￼. By tailing this log, you can observe if perhaps a resize event was processed out of order, or if a paste was split into multiple messages, etc. Bubble Tea’s authors recommend this message dumping for debugging complex interactions ￼.

On the tmux side, you can run tmux in verbose logging mode. Starting tmux with tmux -vv new (or adding -vvv for maximal verbosity) will produce log files in /tmp/tmux-client-_.log, /tmp/tmux-server-_.log, and /tmp/tmux-out-\*.log ￼ ￼. The server log (tmux-server.log) is especially useful – it records all input/output to panes and internal state changes. By inspecting this, you can see if tmux thought it sent certain text to your client or if the cursor moved but your UI missed it. For instance, if a portion of output is missing in your UI, check the tmux-out log to see if those bytes were ever delivered. If they are in tmux’s log but not on your screen, your capture/polling might be skipping data (maybe a timing issue). Tmux verbose logs will also show format variables evaluation if you use them, helping verify things like cursor_y at various times.

Another helpful trick is to use tmux’s built-in capture for debugging. You can manually run tmux capture-pane -p in a shell to get the current pane text and compare it to what your UI shows. Doing this at various moments (especially when you suspect desync) can pinpoint if your UI fell behind. Some developers set up an automated “snapshot” trigger – e.g., pressing a certain key in the UI could capture the pane to a file and also dump the UI’s internal buffer to a file, then you can diff them.

For cursor issues, log the cursor_x,y each frame alongside what your UI believes is the cursor position. If you find a discrepancy, trace back whether perhaps a rapid sequence of cursor movements was not fully captured. (E.g., an application might hide the cursor, move it, print, and show it – if your polling interval caught the text but not the moment after cursor moved, you might place the cursor wrongly.)

Don’t overlook the value of heavy instrumentation: temporarily modify your code to print every raw byte received from tmux in hex, or every escape sequence processed. It can be noisy, but for tricky timing bugs it’s illuminating. You could pipe tmux’s output to a file by using tmux pipe-pane -O (to append) on the pane. This will log all output bytes that go to that pane. Your UI is consuming the same bytes (in theory). If something is stale, compare your UI’s last received chunk with the log. Perhaps your polling missed a final update because it polled before the last chunk arrived. If so, you might implement an immediate re-poll on certain triggers (like an input event, to catch an update that happened just after a keypress).

Another angle: use differential testing by running a real tmux client alongside your proxy. For example, attach to the same session in an actual terminal emulator (tmux allows multiple clients). Then, if your UI desynchronizes, you can see the real tmux output in the terminal vs. your UI’s output side by side. This has helped others notice, say, that the viewer missed a line that the real tmux showed (perhaps due to a race condition in capture timing).

In terms of tooling, since your project is Go-based, you can integrate Go’s pprof to ensure CPU usage is where you expect (e.g., not spending too much time rendering when idle). A spike in CPU might correlate with a flood of messages that caused a desync. Logging timestamps with each poll and each render can also highlight if your UI wasn’t updating when it should.

Finally, as mentioned, tmux control mode can assist in debugging: if you switch to control mode for a test, you’ll get fine-grained output events. You can then verify if perhaps your polling loop is coalescing multiple smaller updates into one and missing an intermediate cursor move. Control mode gives you every chunk as %output. You don’t necessarily ship that way, but for debugging it’s great because it’s event-driven. If you see tmux sent “cursor goes to (10,5)” but your UI cursor ended up at (10,4), you’ve identified the bug in your translation.

To summarize debugging steps:
• Enable verbose logging on tmux and reproduce the issue; examine the logs for anomalies (missing output, etc.) ￼.
• Log your program’s internal state (pane text snapshots, cursor, incoming msgs) to find where it diverges ￼.
• Use tmux’s own capture and pipe-pane as ground truth to compare against your UI.
• Run a real tmux client in parallel to visually catch any divergence.
• Break the problem down: if only the cursor is wrong but text is right, focus on how you place the cursor (maybe an off-by-one as discussed). If text is missing, focus on the polling logic (maybe the final chunk wasn’t captured because the app output occurred right after your last poll – a solution might be to poll once more on idle exit).

Instrumentation and careful comparison are your friends here. Many of these bugs come from the asynchronous nature of terminal output. By capturing timelines of events (with timestamps in logs), you can often see that, say, tmux delivered data at 12:00:00.123, but your UI only polled at 12:00:00.100 and next at 12:00:00.200, so it missed the interim update. That tells you to adjust timing or trigger an extra poll on input, etc. With patience, using the above techniques, you can squash those desync issues and ensure your tmux viewer stays perfectly in lockstep with tmux’s state.
